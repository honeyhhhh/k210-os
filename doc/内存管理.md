# 内存管理
内存管理使用伙伴算法进行管理。

## 伙伴算法
伙伴分配的实质就是一种特殊的“分离适配”，即将内存按2的幂进行划分，相当于分离出若干个块大小一致的空闲链表，搜索该链表并给出同需求最佳匹配的大小。其优点是快速搜索合并（O(logN)时间复杂度）以及低外部碎片（最佳适配best-fit）；其缺点是内部碎片，因为按2的幂划分块，如果碰上66单位大小，那么必须划分128单位大小的块。但若需求本身就按2的幂分配，比如可以先分配若干个内存池，在其基础上进一步细分就很有吸引力了。
>参考：https://coolshell.cn/articles/10427.html
### 优化 1
XOS中的伙伴算法基于上述链接的实现方法进行改进实现。链接文档中管理节点使用的是uint类型，为节省空间，XOS使用logN（N当前区间上所能够分配的内存）。
### 优化 2
假设管理的内存单元个数为n（字节），则二叉树结点为2n-1，如果最小分配单元为2字节，则二叉树结点为n-1，如果最小分配单元为4字节，则二叉树结点为n/2-1，如果最小分配单元为8字节，则二叉树结点为n/4-1。
### 优化 3
此时如果每个结点占用1位空间，则所有结点占用 n / 32 字节 - 1位（最小分配为8Byte），但是很难通过01计算得到结点真实值。而最后两层，即8、16字节层使用01表示很容易判断内存块大小。

```c
if (in_bitmap(b,index))
{
    if (in_bitmap(b, PARENT(index)))  // 8字节层
    {
        if (bitmap_scan_test(b, index))
            size = log2(8);
    }
    else    // 16字节层
    {
        if (bitmap_scan_test(b, index))  //为0
        {
            bool l = bitmap_scan_test(b, LEFT_LEAF(index));
            bool r = bitmap_scan_test(b, RIGHT_LEAF(index));
            if (l&&r)
                size = log2(16);
            else if (l||r)
                size = log2(8);
            else
                size = 0;
        }
    }
}
else
{
    size = b->bbt[index];
}
```
>节选自bitmap_buddy.c - get_size()

### 优化结果
这样将伙伴分配器本身占用的内存为 (n / 16-1)字节 + (n / 8 + n / 16)/8字节  ≈  n/10字节。
### 伙伴分配器
```c
struct bitmap_buddy
{
    struct spinlock lock;
    uintptr_t *space;           // 管理的空间
    uint64_t size;              // 管理空间大小
    uint64_t min_alloc_size;    // 最小分配单位 = 8Byte
    uint8_t bbt[1];             // 完全二叉树
};
```
## 内核临时堆
内核临时堆是用于内核临时分配内存。使用上述伙伴分配器管理堆空间。XOS内核临时堆的大小为128K。

## 页管理

### 启动页管理
通过修改 S 特权级的一个名为 satp 的 CSR 来启用分页模式。

#### satp 的字段分布
```
+---------------------------------------------------+
| MODE(WARL) | ASID(WARL) |         PPN(WARL)       |
+---------------------------------------------------+
     4             16                  44
```
当 MODE 设置为 0 的时候，代表所有访存都被视为物理地址；而设置为 8 的时候，SV39 分页机制被启用。

### 地址格式与组成
#### Virtual Address
```
+-----------------------------------------+
|   Virtual Page Number   |  Page Offset  |
+-----------------------------------------+
            27                   12
```
#### Physical Address
```
+----------------------------------------------------+
|      Physical Page Number      |     Page Offset   |
+----------------------------------------------------+
            44                             12
```
每个页面的大小为 4KB ，虚拟页面和物理页面 4KB 大小对齐。address的低12位是页内偏移，其他高位表示虚拟页号或物理页号。
可以看到虚拟地址和物理地址能表示的地址范围不同，但都足够表示CPU能访问的内存地址空间，因此地址范围的不同不会影响地址的表示。

### 三级页表
页表本身需要在内存中存储，如果使用一个大数组顺序表示的话，必须在初始化是直接分配足够管理内存的页表，这样的话页表本身将占用大量的内存，很不实际。通过多级页表，可以降低页表本身的内存，并且可以按需分配。

risc-v 使用三级页表。每个页表项占用 8 Byte ，每个页表中存储 512 个页表项。`512 = 2^9` ，所以用 9 位就可以表示一个页号，三级页表需要三个页号进行索引，共需要 `3 * 9 = 27` 位索引，可以看到 Virtual Address 中的 Virtual Page Number 为 27 位。

每个页表项 8Byte = 64b ，由于每个页表 4KB 对齐，页表地址的低 12 位为 0 ，在页表项中就可以使用这 12 位做属性位。高 52 位中存储 Physical Page Number 。通过三级索引就可以找到虚拟地址映射的物理地址。

## 物理页帧管理
